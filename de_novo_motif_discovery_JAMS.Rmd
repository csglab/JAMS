---
title: "de_novo_motif_discovery"
output: html_document
---

###### libraries
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
require(data.table)
require(ggplot2)
require(ggseqlogo)
require(ggforce)
require(gridExtra)
require(ggpubr)
require(optparse)
library(reticulate)
suppressPackageStartupMessages(require(ComplexHeatmap))
suppressPackageStartupMessages(require(circlize))
suppressPackageStartupMessages(require(MASS))
suppressPackageStartupMessages(require(patchwork))

knitr::opts_knit$set(root.dir = getwd())
source( "./src/Methyl_ChIP_ftns.R" )
```

###### Load data
```{r}
flanking <- 20
# input_root <- "./data/CTCF_demo/05_motif_discovery/data_CTCF_start/"
input_root <- "./data/CTCF_demo/02_formatted_data/smallest_demo"

###################################################################### #
fileName <- list.files( path=input_root,
                        pattern=paste0( 
                        "*_aligned_sequences.fasta.accessibility" ), 
                        full.names = T )
acc <- fread(fileName,sep="\t", data.table = F, header = F)
# remove peaks with all NAs in the range
acc <- acc[complete.cases(acc), ]                         

acc_names <- acc$V1
acc <- acc[,6:ncol(acc)]

## Replace 0 for pseudocount. As we will use log of DNA_acessibility for model and visualization.
acc[acc == 0] <- NA # All the columns except for the names.
minimum <- min( acc, na.rm = TRUE )
pseudocount <- median( sort(as.numeric(as.vector(as.matrix( acc))) ), na.rm = TRUE ) * 0.01

cat( paste0( "\nMinimum value for DNA accessibility (before average or log): ", 
             minimum, "\n", "Pseudocount: ", pseudocount, "\n" ) )
acc[ is.na( acc ) ] <- pseudocount

## We are assuming that the input files are centered 
# take the part of the sequence that's in range
center <- as.integer(ncol(acc)/2)

rownames(acc) <- acc_names
# acc$Name <- row.names(acc)


###################################################################### #
fileName <- list.files(path=input_root, pattern="*_aligned_sequences_tabulated_mx.txt",full.names = T)
seq <- fread(fileName,sep="\t", data.table = F, header = F)

rownames(seq) <- seq$V1
seq <- seq[, -c(1,2,3,4,5)]

Cs <- (seq=="C") * 1 # find all the Cs
Gs <- (seq=="G") * 1 # find all the Gs
CpGs <- cbind( Cs[,-ncol(Cs)] * Gs[,-1], rep(0,nrow(Cs)) ) 
## find all Cs that are followed by a G (the C in a CpG)
# also find any entry that follows a mark from the previous step (i.e. also mark the Gs in a CpG)
CpGs[,-1] <- CpGs[,-1] + CpGs[,-ncol(CpGs)] 

rownames(CpGs) <- rownames(seq)

# remove sequences with Ns. These sequences will later be removed from the CpG matrix based on sequence name
# seq <- seq[ apply( seq[,-1], 1, function(x) sum(x=="N") ) == 0, ]
  
# Set the column names
colnames(seq) <- c(paste0("pos_",1:ncol(seq) ) ) # ah_flank
colnames(CpGs) <- c(paste0("pos_",1:ncol(CpGs) ) ) # ah_flank



###################################################################### #
fileName <- list.files(path=input_root, pattern=paste0("*_sequences.fasta.methylreads"), full.names = T)
methyl <- fread(fileName,sep="\t", data.table = F, header = F)

rownames(methyl) <- methyl$V1
methyl <- methyl[, -c(1,2,3,4,5) ]
methyl <- methyl[ apply( methyl, 1, function(x) sum(!is.na(x)) ) > 0, ]
# Set the column names
colnames(methyl) <- c(paste0("pos_",1:ncol(methyl) ) ) # ah_flank

  
###################################################################### #
fileName <- list.files(path=input_root, 
                       pattern=paste0("*_aligned_sequences.fasta.nonmethylreads"),
                       full.names = T)
nonmethyl <- fread(fileName,sep="\t", data.table = F, header = F)

rownames(nonmethyl) <- nonmethyl$V1
nonmethyl <- nonmethyl[, -c(1,2,3,4,5) ]

# remove peaks with all NAs in the range  
nonmethyl <- nonmethyl[ apply( nonmethyl, 1, function(x) sum(!is.na(x)) ) > 0, ]
# Set the column names
colnames(nonmethyl) <- c(paste0("pos_",1:ncol(nonmethyl) ) ) # ah_flank


fileName <- list.files( path = input_root, full.names = TRUE,
                        pattern = "*_summits_vRepeats_scores.txt" )
target <- fread( fileName, sep = "\t", data.table = FALSE, header = TRUE )
rownames(target) <- target$Name


# row.names(seq) <- seq$Name
# row.names(methyl) <- methyl$Name
# row.names(nonmethyl) <- nonmethyl$Name
# row.names(acc) <- acc$Name
# 
include <- Reduce( intersect, list( rownames(seq), 
                                    rownames(methyl), 
                                    rownames(nonmethyl), 
                                    rownames(acc),
                                    rownames(target) ) )

# include <- include[1:10000] # test with smaller number of peaks.
acc <- acc[ include , ]
seq <- seq[ include , ]
CpGs <- CpGs[ include , ]
methyl <- methyl[ include , ]
nonmethyl <- nonmethyl[ include , ]
target <- target[ include, ]

## Methyl and non methyl reads are not over A or T, only over G and C.
#####
if( sum(is.na(methyl[seq=="C"])) > 0 | sum(is.na(methyl[seq=="G"])) > 0 |
    sum(is.na(nonmethyl[seq=="C"])) > 0 | sum(is.na(nonmethyl[seq=="G"])) > 0 ) {
  stop("NA's found where methylation read counts were expected.")
}
if( sum(!is.na(methyl[seq=="A"])) > 0 | sum(!is.na(methyl[seq=="T"])) > 0 |
    sum(!is.na(nonmethyl[seq=="A"])) > 0 | sum(!is.na(nonmethyl[seq=="T"])) > 0 ) {
  stop("Methylation read counts found where NA's were expected.")
}
#####

```

###### Prepare data
```{r}
## Preparation
# extract the sequence matrix and convert it to one-hot encoding
x.A.all <- ( seq == "A" ) * 1
x.C.all <- ( seq == "C" ) * 1
x.G.all <- ( seq == "G" ) * 1
x.T.all <- ( seq == "T" ) * 1
# rownames(CpGs) <- CpGs$Name
x.CpG.all <- CpGs * 1

ncolx <- ncol(x.A.all)
x.CG.all <- x.C.all[,-ncolx] * x.G.all[,-1]

## Calculate the fraction of methylated C's in the reverse strand 
##  (in front of every G)
x.W.all <- x.G.all * ( methyl + 1 ) / ( methyl + nonmethyl + 2 ) 
## Calculate the fraction of methylated C's in the forward strand
x.M.all <- x.C.all * ( methyl + 1 ) / ( methyl + nonmethyl + 2 ) 

## Methylation in reverse strand
# replace NA values by zero (these correspond to A/T nucleotides)
x.W.all[ is.na(x.W.all) ] <- 0
# only keep the W's that are within a CpG
x.W.all <- x.W.all * x.CpG.all
## Methylation in forward strand
# replace NA values by zero (these correspond to A/T nucleotides)
x.M.all[ is.na(x.M.all) ] <- 0
# only keep the W's that are within a CpG
x.M.all <- x.M.all * x.CpG.all

## Methylation average M (forward) W (reverse).
x.Met.all <- ( ( x.M.all[,-ncolx] + x.W.all[,-1] ) / 2 )


rm(CpGs, ncolx, fileName, include, pseudocount, center, acc_names, seq, Gs, Cs, 
   methyl, nonmethyl, input_root, minimum )
```

For the de novo motif finding, 
I think the main idea is to “dynamically” align the peaks based on the
motif/accessibility/methylation score of the JAMS model, retrain the model, 
and repeat. So, something like this:

1. Start with peak sequence/accessibility/methylation matrices that 
   are initially aligned simply based on the peak center.

2. Train the JAMS TF and background parameters.

3. For each peak, identify the position that would result in the 
   maximum JAMS TF score if it was used as the “center point”.

4. Re-align the peaks based on the newly identified center points.
   By re-aligning, I mean simply sliding each row of the input 
   matrices to the left or right, so that the center 
   points are now aligned.

5. Repeat 3-4, until convergence.

```{r}
source_python("./src/motif_discovery.py")
shift_per_row <- function( shift_pos, df, region_len ){

  new_df <- shift_per_row_py( as.vector( shift_pos ), 
                              as.matrix( df ), 
                              as.integer( region_len ) )
  
  new_df <- t( as.data.frame( new_df ) )
  
  # colnames( new_df ) <- colnames( new_df )
  rownames( new_df ) <- rownames( df ) 
  
  return( new_df ) }


## Where are we starting? center
# start_pos_motif <- 100
start_pos_motif <- floor( x = ncol(seq)/2 ) # 100
pfm_length <- 7
stop_position <- 201
flanking <- 20


dat_all <- list( acc = as.data.frame(acc),
                 x.Met.all = as.data.frame(x.Met.all),
                 x.A.all = as.data.frame(x.A.all),
                 x.C.all = as.data.frame(x.C.all), 
                 x.G.all = as.data.frame(x.G.all),
                 x.T.all = as.data.frame(x.T.all), 
                 x.CpG.all = as.data.frame(x.CpG.all),
                 x.CG.all = as.data.frame(x.CG.all),
                 target = as.data.frame(target),
                 x.M.all = as.data.frame(x.M.all), 
                 x.W.all = as.data.frame(x.W.all ) )

rm( x.Met.all, x.A.all, x.C.all, x.G.all, x.T.all, x.CpG.all, x.CG.all, 
    acc, x.M.all, x.W.all )

```



```{r}
get_bin_acc <- function( acc ){
  acc <- data.frame( bin_down_5 = rowMeans( acc[,0:200] ),
                     bin_down_4 = rowMeans( acc[,200:400] ),
                     bin_down_3 = rowMeans( acc[,400:600] ),
                     bin_down_2 = rowMeans( acc[,600:800] ),
                     bin_down_1 = rowMeans( acc[,800:1000] ),
                     bin_motif =  rowMeans( acc[,1000:(1000+pfm_length)] ),
                     bin_up_1 =   rowMeans( acc[,(1000+pfm_length):(1200+pfm_length)] ),
                     bin_up_2 =   rowMeans( acc[,(1200+pfm_length):(1400+pfm_length)] ),
                     bin_up_3 =   rowMeans( acc[,(1400+pfm_length):(1600+pfm_length)] ),
                     bin_up_4 =   rowMeans( acc[,(1600+pfm_length):(1800+pfm_length)] ),
                     bin_up_5 =   rowMeans( acc[,(1800+pfm_length):(2000+pfm_length)] ))
  return(acc) }

train_GLM_at_shifted_pos <- function( flanking, pfm_length, dat_all, start_pos ){
  
  # flanking = flanking
  # pfm_length = pfm_length
  # dat_all = dat_all
  # start_pos = start_pos
  
  region_len <- 2*flanking + pfm_length
  
  x.A <- shift_per_row(start_pos$region_start_pos, dat_all$x.A.all, region_len)
  x.C <- shift_per_row(start_pos$region_start_pos, dat_all$x.C.all, region_len)
  x.G <- shift_per_row(start_pos$region_start_pos, dat_all$x.G.all, region_len)
  x.T <- shift_per_row(start_pos$region_start_pos, dat_all$x.T.all, region_len)
  x.CpG <- shift_per_row(start_pos$region_start_pos, dat_all$x.CpG.all, region_len)
  x.CG <- shift_per_row(start_pos$region_start_pos, dat_all$x.CG.all, region_len)
  x.Met <- shift_per_row( start_pos$region_start_pos, dat_all$x.Met.all, region_len)
  
  x.M <- shift_per_row( start_pos$region_start_pos, dat_all$x.M.all, region_len)
  x.W <- shift_per_row( start_pos$region_start_pos, dat_all$x.W.all, region_len)
 
   
  region_len <- 2000 + pfm_length
  acc <- shift_per_row( start_pos$acc_start_pos, dat_all$acc, region_len )
  acc <- get_bin_acc( acc )
  
  #### 
  x.T_up <- rowSums( x.T[, 1:flanking] )
  x.C_up <- rowSums( x.C[, 1:flanking] )
  x.G_up <- rowSums( x.G[, 1:flanking] )
  x.M_up <- rowMeans( x.M[, 1:flanking] )
  x.W_up <- rowMeans( x.W[, 1:flanking] )
  
  x.T_down <- rowSums(x.T[, (flanking+pfm_length):(flanking+pfm_length-1)])
  x.C_down <- rowSums(x.C[, (flanking+pfm_length):(flanking+pfm_length-1)])
  x.G_down <- rowSums(x.G[, (flanking+pfm_length):(flanking+pfm_length-1)])
  x.M_down <- rowSums(x.M[, (flanking+pfm_length):(flanking+pfm_length-1)])
  x.W_down <- rowSums(x.W[, (flanking+pfm_length):(flanking+pfm_length-1)])
  
  x.C <- x.C[, flanking:(flanking+pfm_length-1) ]
  x.A <- x.A[, flanking:(flanking+pfm_length-1) ]
  x.G <- x.G[, flanking:(flanking+pfm_length-1) ]
  x.T <- x.T[, flanking:(flanking+pfm_length-1) ]
  x.CpG <- x.CpG[, flanking:(flanking+pfm_length-1) ]
  x.Met <- x.Met[, flanking:(flanking+pfm_length-1) ]
  x.CG <- x.CG[, flanking:(flanking+pfm_length-1) ]
  
  
  ### Train GLM 
  # c_tags <- as.data.frame( c( dat_all$target$ctrl.tag.old, 
  #                             dat_all$target$pulldown.tag.old ) )
  # colnames(c_tags) <- "c"
  # rownames( c_tags ) <- c( paste0( "control.", dat_all$target$Name ), 
  #                          paste0( "pulldown.", dat_all$target$Name ) )
  c_tags <- unlist( c( dat_all$target$ctrl.tag.old, 
                       dat_all$target$pulldown.tag.old ) )
  
  
  # t_all <- as.data.frame( c( rep( 0, nrow( dat_all$target ) ), 
  #                            rep( 1, nrow( dat_all$target ) ) ) )
  # rownames( t_all ) <- c( paste0( "control.", dat_all$target$Name ), 
  #                         paste0( "pulldown.", dat_all$target$Name ) )

  t <- unlist( c( rep( 0, nrow( dat_all$target ) ), 
                  rep( 1, nrow( dat_all$target ) ) ) )
  
  XX <- data.frame( acc = acc, x.C = x.C, x.G = x.G, x.T = x.T,
                    x.CG = x.CG, x.Met = x.Met,
                    x.T_up = x.T_up, x.C_up = x.C_up, 
                    x.G_up = x.G_up,x.M_up = x.M_up, 
                    x.W_up = x.W_up, x.T_down = x.T_down, 
                    x.C_down = x.C_down, x.G_down = x.G_down,
                    x.M_down = x.M_down, x.W_down = x.W_down, 
                    stringsAsFactors = TRUE  )
  
  rownames( XX ) <- NULL
  XX <- rbind( XX, XX )
  rownames( XX ) <- c( paste0( "control.", target$Name ), 
                       paste0( "pulldown.", target$Name ) )
  
  return( MASS::glm.nb( c_tags ~ . + t + .:t, data = XX ) )
  }

## The starting position here makes the center of the motif is at the center of the peaks
# region_offset <- floor( ( (2*flanking + pfm_length)/2 ) )
motif_offset <- floor( pfm_length/2 )



shift_pos <- rep_len(x = motif_offset, # Start at peak's middle
                     length.out = nrow(dat_all$x.Met.all)) # Number of ChIP-seq peaks

## Motif starting position - at the peak's middle.
start_pos <- list( region_start_pos = 100 - shift_pos - flanking,
                      acc_start_pos = 1500 - 1000 - shift_pos )



this_glm <- train_GLM_at_shifted_pos( flanking = flanking, 
                                      pfm_length = pfm_length, 
                                      dat_all = dat_all,
                                      start_pos = start_pos )

```



```{r}
aa <- dat_all[["x.Met.all"]]

aaa <- aa[, "*1"]


subset(aa, grepl("blue", aa$x))

```




```{r}
## Get all coefficients from the GLM (trained set)
fit_coefficients <- as.data.frame( coefficients( summary( this_glm ) ) )

## Get the pulldown coefficients
fit_pdwn_coefficients <- fit_coefficients[grepl(pattern = ":t$", 
                                          x = rownames(fit_coefficients)),]

## Get the name of the variables included in th model    
X_var_names <- gsub( ":t", "", rownames( fit_pdwn_coefficients ) )

## XX at the first pos

## Make sure those variables are in the correct order for the matrix*vector
XX_test <- as.matrix(XX[, X_var_names])


## Mult. the PULLDOWN coeffs vector and the variable matrix
c_pdwn_predicted <- as.vector( XX_test %*% fit_pdwn_coefficients$Estimate ) # 1st must be 1.2476048 in test
# Only the first half of XX
c_pdwn_predicted <- c_pdwn_predicted[ 1 : ( length( test_names ) / 2 ) ]
    

log_c_ratio_predicted <- c_pdwn_predicted
    
all_c_predicted <- append(all_c_predicted, log_c_ratio_predicted)
all_c_real <- append(all_c_real, log_c_ratio_observed )

```




```{r}
# ## Left Limit ; ## Right Limit
# left_lim <- ( 1 + flanking )
# right_lim <- ( stop_position - flanking - pfm_length + 1 )
 
# start_pos_motif <- left_lim
# start_pos_motif <- right_lim
# 
# ## Define motif/upstream/downstream
# upsteam_flank <- paste0( "pos_", (start_pos_motif-flanking):(start_pos_motif-1) )
# motif <- paste0( "pos_", start_pos_motif:(start_pos_motif+pfm_length-1) )
# downsteam_flank <- paste0( "pos_",
#           (start_pos_motif+pfm_length):(start_pos_motif+pfm_length+flanking-1) )
# 
# 
# x.M_up <- rowMeans( x.M.all[, upsteam_flank] )
# x.W_up <- rowMeans( x.W.all[, upsteam_flank] )
# x.T_up <- rowSums( x.T.all[, upsteam_flank] )
# x.C_up <- rowSums( x.C.all[, upsteam_flank] )
# x.G_up <- rowSums( x.G.all[, upsteam_flank] )
# 
# x.M_down <- rowMeans( x.M.all[, downsteam_flank] )
# x.W_down <- rowMeans( x.W.all[, downsteam_flank] )
# x.T_down <- rowSums(  x.T.all[, downsteam_flank] )
# x.C_down <- rowSums(  x.C.all[, downsteam_flank] )
# x.G_down <- rowSums(  x.G.all[, downsteam_flank] )
# 
# x.C <- x.C.all[, motif]
# x.A <- x.A.all[, motif]
# x.G <- x.G.all[, motif]
# x.T <- x.T.all[, motif]
# x.CpG <- x.CpG.all[, motif]
# x.Met <- x.Met.all[, motif]
# x.CG <- x.CG.all[, motif]

```



















